# Test_for_Qrator_2
Отчет по тестовому заданию #2 для соискателя позиции C/C++ Developer в компании Qrator

## Описание задачи
Реализовать ThreadPool (на C++ под linux, без использования C++11):<br>
- конструктор имеет один параметр - число воркеров, которые будут выполнять задачи.<br>
- метод Enqueue имеет два параметра - объект(ссылку на объект), описывающий задачу, которую надо будет выполнить (например абстрактного типа с методом .do()) и приоритет(пусть всего будет три приоритета - low, normal, high).<br>
- метод Stop() - ожидает завершения выполняемых (в данный момент) задач, после чего убивает воркеры и возвращает управление.

Enqueue добавляет задачи в очередь на выполнение и возвращает true (если до этого не был вызван Stop - в этом случае Enqueue возвращает false).

Приоритеты обрабатываются следующим образом:<br>
а) low-задачи не выполняются никогда, пока в очереди есть хотя бы одна задача с другим приоритетом.<br>
б) на 3 high-задачи выполняется 1 normal-задача.<br>
Данная логика относится только к выборке задачи из очереди, уже запущенные задачи приоритизировать не требуется.

## Окружение
Система: Ubuntu 15.10<br>
IDE: Eclipse CDT

## Сборка
Для сборки нужно вызвать make в папке build.

## Описание
Пулл содержит три очереди, соответствующие заданным приоритетам.
При добавлении задачи, она помещается в очередь соответствующую приоритету. Помещение в очередь защищено мьютексом. Ожидающие потоки оповещаются через условную переменную.
Воркеры порождаются в конструкторе пула, в количестве, переданном в аргументе.
Воркер в цикле извлекает очередную задачу из очереди, выбранную в соответствии с условиями. Извлечение из очереди защищено мьютексом. Если очереди пусты, воркер ждет оповещения на условной переменной.
При остановке пула выставляется флаг остановки. При его наличии воркер в очередной итерации рабочего цикла не извлекает очередную задачу, а завершает выполнение.
Для обработки разнородных задач испольется класс-интерфейс, от которого наследуются классы задач.